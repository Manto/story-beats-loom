from pathlib import Path

import networkx as nx
from tqdm import tqdm

from .models import InteractiveStory
from .prompt import generate_prompt
from .llm import make_llm_inference


class StoryBeatsLoom:
    story_outline: InteractiveStory
    story_graph: nx.DiGraph | None = None
    story_paths: list[list[str]] | None = None
    generated_story: InteractiveStory | None = None

    def __init__(self, story_outline):
        self.story_outline = story_outline

    def walk_story_paths(self):
        if self.story_paths is None:
            self.story_graph = self.build_story_graph()
            self.story_paths = list(self.get_story_paths())

    def get_story_paths(self):
        for node in self.story_graph.nodes():
            if node == "start":
                continue
            yield from nx.all_simple_paths(story_graph, "start", node)

    def build_story_graph(self):
        nodes = (node for node in self.nodes)
        edges = (
            # (source, dest)
            (node.name, link)
            for node in self.nodes.values()
            for link in node.links
        )
        g = nx.DiGraph()
        g.add_nodes_from(nodes)
        g.add_edges_from(edges)
        return g

    def generate_story(self, provider="anthropic"):
        if not self.story_paths:
            raise Exception("Must walk story path before generating story.")

        self.generated_story = self.story_outline.generate_copy()
        # TODO - path independent nodes
        # Generated text is path dependent
        # so stored by entire path as key/exported node name
        # eg. Start > Left > North ==> "Start_Left_North"

        # Note: Convert paths into a list for better tqdm display
        for path in tqdm(list(self.story_paths), desc="building text for paths"):
            # Track the path we followed to get to each node
            path_key = []
            # Track the cumulative text generated so far, in each path
            cumulative_text = ""
            for node_name in tqdm(path, leave=False, desc=f"{'>'.join(path)}"):
                # Path -> path keys
                # e.g. "start__A__B" etc
                parent_key = "__".join(path_key)
                path_key.append(node_name)
                # Node path -> node key
                # E.g. "start__A__B__C" , if in node C etc
                node_key = "__".join(path_key)
                # Note: starting node has to be named start! TODO
                if node_name != "start":
                    # Add text generated by the parent to the cumulative text
                    cumulative_text += self.generated_story.get_node(parent_key).text

                # Check if this specific node's text is already generated
                if node_key not in self.generated_story.nodes:
                    outline_node = self.story_outline.get_node(node_name)
                    system, prompt = generate_prompt(
                        cumulative_text,
                        genre=self.story_outline.genre,
                        pov=self.story_outline.pov,
                        style=self.story_outline.style,
                        tone=self.story_outline.tone,
                        setting=self.story_outline.setting,
                        plot=outline_node.plot,
                    )

                    generated_text = make_llm_inference(provider, system, prompt)

                    # Build generated story node corresponding to outline node
                    # with new path dependent node name
                    generated_node = self.generated_story.build_generated_node(
                        outline_node, generated_text, node_key
                    )
                    generated_node.prompt = prompt

        return self.generated_story


def generate_story_from_outline(outline_yaml, provider):
    print("[+] Parsing story yaml file...")
    story = InteractiveStory.from_outline_yaml(outline_yaml)
    loom = StoryBeatsLoom(story_outline=story)

    print("[+] Generating all paths through story...")
    loom.walk_story_paths()

    print("[+] Cumulatively generating story text for each node in each path...")
    generated_story = loom.generate_story(provider)

    return generated_story
